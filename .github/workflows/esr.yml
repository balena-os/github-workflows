name: "Create ESR branch and tag"

on:
  workflow_call:
    inputs:
      esr-version:
        required: false
        type: string
        description: ESR version override, for example 2022.10. By default it uses the current year and month.
      os-version:
        required: false
        type: string
        description: OS ESR version override, for example 2.104. By default it uses the latest ESR branch.
    secrets:
      ESR_BOT_PRIVATE_KEY:
        required: true
        description: Private key for the ESR bot GitHub App

jobs:
  fetch:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.10"]
    outputs:
      status: ${{ join(steps.*.conclusion) }}
    steps:
      # https://github.com/actions/create-github-app-token
      - name: Generate GitHub App installation token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2.2.1
        id: app_token
        with:
          app-id: ${{ vars.ESR_BOT_APP_ID || '400859' }}
          private-key: ${{ secrets.ESR_BOT_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: ${{ github.event.repository.name }}

      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        id: checkout
        with:
          submodules: "recursive"
          fetch-depth: 0
          ref: "master"
          # The default GITHUB_TOKEN does not have workflow scope
          # This is needed to push a new branch with workflow files
          token: ${{ steps.app_token.outputs.token }}
          # For now we still perform a bunch of git commands that require credentials
          # and expect the credentials to be cached like fetch and submodule updates
          persist-credentials: true

      - name: "Only run for device repositories"
        id: assert-device-repository
        run: |
          if [ -f "$(pwd)/repo.yml" ]; then
            if grep -q "yocto-based OS image" repo.yml; then
              exit 0
            fi
          fi
          exit 1

      - name: Validate inputs
        id: validate-inputs
        run: |
          if [ "${{ github.event.inputs.esr-version }}" != "" ]; then
            if ! [[ "${{ github.event.inputs.esr-version }}" =~ ^[1-3][0-9]{3}\.[0-1]?[0-9]$ ]]; then
              echo "Invalid ESR version ${{ github.event.inputs.esr-version }}"
              exit 1
            fi
            esr_version=${{ github.event.inputs.esr-version }}
          else
            esr_version="$(date '+%Y').$(echo "$(date '+%m')" | sed "s/^0*//")"
            if ! [[ "${esr_version}" =~ ^[1-3][0-9]{3}\.[0-1]?[0-9]$ ]]; then
              echo "Invalid ESR version ${esr-version}. Please use the esr-version input argument to force one."
              exit 1
            fi
          fi
          esr_branch="${esr_version}.x"
          echo "esr_version=${esr_version}.0" >> "${GITHUB_OUTPUT}"
          echo "esr_branch=${esr_branch}" >> "${GITHUB_OUTPUT}"
          echo "ESR version: ${esr_version}.0"
          echo "ESR branch ${esr_branch}"

      - name: Check if ESR branch already exists
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          REF: heads/${{ steps.validate-inputs.outputs.esr_branch }}
        with:
          github-token: ${{ steps.app_token.outputs.token }}
          script: |
            const ref = process.env.REF;
            try {
              await github.rest.git.getRef({
                ...context.repo,
                ref,
              });
              // If we get here, the ref exists
              core.setFailed(`Ref ${ref} already exists`);
            } catch (error) {
              if (error.status === 404) {
                console.log(`Ref ${ref} does not exist, proceeding`);
              } else {
                throw error;
              }
            }

      - name: Check if ESR tag already exists
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          REF: tags/v${{ steps.validate-inputs.outputs.esr_version }}
        with:
          github-token: ${{ steps.app_token.outputs.token }}
          script: |
            const ref = process.env.REF;
            try {
              await github.rest.git.getRef({
                ...context.repo,
                ref,
              });
              // If we get here, the ref exists
              core.setFailed(`Ref ${ref} already exists`);
            } catch (error) {
              if (error.status === 404) {
                console.log(`Ref ${ref} does not exist, proceeding`);
              } else {
                throw error;
              }
            }

      - name: "Select meta-balena ESR branch"
        id: select-meta-balena-esr-branch
        run: |
          pushd layers/meta-balena || true > /dev/null 2>&1
          if ! grep -q "yocto layer" repo.yml; then
            echo "Non valid meta-balena layer"
            exit 1
          fi
          # The meta-balena-esr workflow runs the first day of each quarter to create the ESR branch
          if [ "${{ github.event.inputs.os-version }}" != "" ]; then
            if ! [[ "${{ github.event.inputs.os-version }}" =~ ^[0-9]+.[0-9]+$ ]]; then
              echo "Invalid OS version ${{ github.event.inputs.os-version }}"
              exit 1
            fi
            os_esr_base_pattern=${{ github.event.inputs.os-version }}.x
          else
            os_esr_base_pattern="[0-9]*.[0-9]*.x"
          fi
          os_esr_branch=$(git branch -r --list origin/${os_esr_base_pattern} --sort=-version:refname | head -n1 | tr -d ' ')
          bsp_branch_pattern=$(git show remotes/${os_esr_branch}:repo.yml | grep bsp-branch-pattern | cut -d ':' -f2 | tr -d ' ')
          esr_branch=${{ steps.validate-inputs.outputs.esr_branch }}
          if [ "${esr_branch}" != "${bsp_branch_pattern}" ]; then
            echo "[${esr_branch}] BSP match pattern ${bsp_branch_pattern} mismatch."
            exit 1
          fi
          os_esr_base_version=$(git show remotes/${os_esr_branch}:repo.yml | grep version | awk -F"'" '{print $2}')
          os_esr_branch="${os_esr_base_version}.x"
          echo "os_esr_base_version=${os_esr_base_version}" >> $GITHUB_OUTPUT
          echo "os_esr_branch=${os_esr_branch}" >> $GITHUB_OUTPUT
          echo "OS ESR base version ${os_esr_base_version} and branch ${os_esr_branch}"
          popd || true > /dev/null

      - name: "Select base version"
        id: select-base
        run: |
          git fetch --tags origin
          os_esr_base_version=${{ steps.select-meta-balena-esr-branch.outputs.os_esr_base_version}}
          os_esr_branch=${{ steps.select-meta-balena-esr-branch.outputs.os_esr_branch}}
          esr_base_tag=$(git tag --sort -version:refname | grep "^v${os_esr_base_version}" | head -n1)
          if [ -z "${esr_base_tag}" ]; then
            echo "No version based on ${os_esr_base_version}"
            exit 1
          fi
          echo "Base tag: ${esr_base_tag}"
          git checkout -b ${{ steps.validate-inputs.outputs.esr_branch }} refs/tags/${esr_base_tag}
          git submodule update --recursive
          pushd layers/meta-balena || true > /dev/null 2>&1
          git checkout -b ${os_esr_branch} ${os_esr_branch}
          popd || true > /dev/null

      - name: Setup Python
        uses: actions/setup-python@83679a892e2d95755f2dac6acb0bfd1e9ac5d548 # v6
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml

      - name: Update version files
        run: |
          # Modify repo.yml
          python3 <<EOF
          import sys
          import yaml
          filePath = './repo.yml'
          with open(filePath, 'r') as original:
              ydata = yaml.safe_load(original)
          if 'esr' in ydata:
              # Nothing to do
              print("ESR branch already configured")
              sys.exit(1)
          esr_branch = "${{ steps.validate-inputs.outputs.esr_branch }}"
          esrMm = esr_branch[:-2]
          ydata['esr'] = {'version': esrMm}
          with open(filePath, 'w') as modified:
              yaml.dump(ydata, modified)
          EOF
          # Modify VERSION
          python3 <<EOF
          import yaml
          import re
          filePath = "./VERSION"
          with open(filePath, 'r') as original:
              data = original.read()
          (data, count) = re.subn("^\d+\.\d+.\d+(\+rev\d+)?$", "${{ steps.validate-inputs.outputs.esr_version }}", data)
          if count != 1:
              raise
          with open(filePath, 'w') as modified:
              modified.write(data)
          EOF
          # Modify CHANGELOG
          python3 <<EOF
          from datetime import date
          filePath = "./CHANGELOG.md"
          with open(filePath, 'r') as original:
              data = original.readlines()
          if "Change log\n" in data[0]:
              prefix = data[0:2]
              content = data[2:]
              esrVersion = "${{ steps.validate-inputs.outputs.esr_version }}"
              date = date.today().strftime('%Y-%m-%d')
              new = "\n# " + esrVersion + "\n" + \
                  "## (" + date + ")\n\n* Declare ESR " + esrVersion + "\n"
              prefix.append(new)
              prefix.append("".join(content))
              with open(filePath, 'w') as modified:
                  modified.write("".join(prefix))
          EOF

      - name: Write commit message
        env:
          ESR_VERSION: ${{ steps.validate-inputs.outputs.esr_version }}
        run: |
          cat > commit_msg.txt <<-EOF
          Declare ESR ${ESR_VERSION}

          Change-type: none
          EOF

      # https://octokit.github.io/rest.js/v21/#git-create-ref
      # https://docs.github.com/en/rest/git/refs?apiVersion=2022-11-28#create-a-reference
      - name: Create ESR branch
        env:
          REF: refs/heads/${{ steps.validate-inputs.outputs.esr_branch }}
          SHA: ${{ steps.checkout.outputs.commit }}
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          github-token: ${{ steps.app_token.outputs.token }}
          result-encoding: json
          script: |
            const { data: ref } = await github.rest.git.createRef({
              ...context.repo,
              ref: process.env.REF,
              sha: process.env.SHA
            });
            return ref;

      # https://github.com/orgs/community/discussions/50055
      # https://www.levibotelho.com/development/commit-a-file-with-the-github-api/
      # https://octokit.github.io/rest.js/v21/#git-create-blob
      # https://octokit.github.io/rest.js/v21/#git-create-tree
      - name: Create blobs and tree
        id: create_tree
        env:
          PARENT_COMMIT_SHA: ${{ steps.checkout.outputs.commit }}
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          github-token: ${{ steps.app_token.outputs.token }}
          script: |
            const { execSync } = require('child_process');
            const fs = require('fs').promises;

            const parentSha = process.env.PARENT_COMMIT_SHA;
            const baseTreeSha = execSync(`git show -s --format=%T "${parentSha}"`).toString().trim();

            // Files to commit (regular files)
            const files = ['VERSION', 'CHANGELOG.md', 'repo.yml'];

            // Create blob entries for regular files
            const blobEntries = await Promise.all(files.map(async (file) => {
              core.info(`Creating blob for ${file}...`);
              const content = await fs.readFile(file, { encoding: 'utf8' });
              const { data: blob } = await github.rest.git.createBlob({
                ...context.repo,
                content: Buffer.from(content).toString('base64'),
                encoding: 'base64'
              });
              return {
                path: file,
                mode: '100644',
                type: 'blob',
                sha: blob.sha
              };
            }));

            // Get submodule commit SHA (mode 160000, type commit)
            const submodulePath = 'layers/meta-balena';
            const submoduleSha = execSync(`git -C ${submodulePath} rev-parse HEAD`).toString().trim();
            core.info(`Submodule ${submodulePath} at commit ${submoduleSha}`);

            const submoduleEntry = {
              path: submodulePath,
              mode: '160000',
              type: 'commit',
              sha: submoduleSha
            };

            // Create tree with all entries
            const treeEntries = [...blobEntries, submoduleEntry];
            const { data: tree } = await github.rest.git.createTree({
              ...context.repo,
              tree: treeEntries,
              base_tree: baseTreeSha
            });

            core.info(`Created tree ${tree.sha}`);
            core.setOutput('sha', tree.sha);

      # https://octokit.github.io/rest.js/v21/#git-create-commit
      # https://docs.github.com/en/rest/git/commits#create-a-commit
      - name: Create commit
        id: create_commit
        env:
          TREE_SHA: ${{ steps.create_tree.outputs.sha }}
          PARENT_COMMIT_SHA: ${{ steps.checkout.outputs.commit }}
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          github-token: ${{ steps.app_token.outputs.token }}
          script: |
            const fs = require('fs').promises;
            const message = await fs.readFile('commit_msg.txt', { encoding: 'utf8' });

            const { data: commit } = await github.rest.git.createCommit({
              ...context.repo,
              message: message.trim(),
              tree: process.env.TREE_SHA,
              parents: [process.env.PARENT_COMMIT_SHA]
            });

            core.info(`Created commit ${commit.sha}`);
            core.setOutput('sha', commit.sha);

      # https://octokit.github.io/rest.js/v21/#git-update-ref
      - name: Update branch ref
        env:
          REF: heads/${{ steps.validate-inputs.outputs.esr_branch }}
          SHA: ${{ steps.create_commit.outputs.sha }}
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          github-token: ${{ steps.app_token.outputs.token }}
          script: |
            await github.rest.git.updateRef({
              ...context.repo,
              ref: process.env.REF,
              sha: process.env.SHA
            });
            core.info(`Updated ${process.env.REF} to ${process.env.SHA}`);

      # https://octokit.github.io/rest.js/v21/#git-create-tag
      # https://docs.github.com/en/rest/git/tags#create-a-tag-object
      - name: Create a new tag object
        id: create_tag
        env:
          TAG: v${{ steps.validate-inputs.outputs.esr_version }}
          MESSAGE: Declare ESR ${{ steps.validate-inputs.outputs.esr_version }}
          SHA: ${{ steps.create_commit.outputs.sha }}
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          github-token: ${{ steps.app_token.outputs.token }}
          result-encoding: json
          script: |
            const { data: tag } = await github.rest.git.createTag({
              ...context.repo,
              tag: process.env.TAG,
              message: process.env.MESSAGE,
              object: process.env.SHA,
              type: 'commit'
            });
            core.setOutput('sha', tag.sha);
            return tag;

      # https://octokit.github.io/rest.js/v21/#git-create-ref
      # https://docs.github.com/en/rest/git/refs?apiVersion=2022-11-28#create-a-reference
      - name: Create git reference to the tag object
        env:
          REF: refs/tags/v${{ steps.validate-inputs.outputs.esr_version }}
          SHA: ${{ steps.create_tag.outputs.sha }}
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          github-token: ${{ steps.app_token.outputs.token }}
          result-encoding: json
          script: |
            const { data: ref } = await github.rest.git.createRef({
              ...context.repo,
              ref: process.env.REF,
              sha: process.env.SHA
            });
            return ref;
